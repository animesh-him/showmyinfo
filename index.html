<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>What a site can see about you → Risks & Fixes</title>
<style>
  body {font-family: system-ui, sans-serif; max-width: 900px; margin:2rem auto; line-height:1.6;}
  button {font-size:1.1rem;padding:0.6rem 1.2rem;cursor:pointer;}
  pre  {background:#f4f4f4;padding:1rem;overflow:auto;border-radius:4px;}
  .risk {margin-top:1rem;background:#fff8e1;padding:1rem;border-left:4px solid #ff9800;}
  .risk h3 {margin-top:0;}
  .risk ul {margin:0.5rem 0 0 1.2rem;}
</style>
</head>
<body>

<h1>🔎 What a website can see about you (and why it matters)</h1>

<p>
  Click the button below. The page will gather **only the data a website can read without asking for permission** and then show you:
</p>
<ol>
  <li>The raw values (JSON).</li>
  <li>For each value, a short description of the privacy risk.</li>
  <li>Practical steps you can take to reduce or hide that data.</li>
</ol>

<button id="revealBtn">Show my public info</button>

<h2>Collected data</h2>
<pre id="output">– click the button to see info –</pre>

<div id="riskContainer"></div>

<script>
// ---------------------------------------------------------------
// Helper – fetch public IP (free, CORS‑enabled service)
// ---------------------------------------------------------------
async function getPublicIP() {
  try {
    const r = await fetch('https://api.ipify.org?format=json');
    if (!r.ok) throw new Error('Network error');
    const {ip} = await r.json();
    return ip;
  } catch (e) {
    return `Error: ${e.message}`;
  }
}

// ---------------------------------------------------------------
// Helper – WebGL fingerprint (vendor & renderer)
// ---------------------------------------------------------------
function getWebGLFingerprint() {
  try {
    const c = document.createElement('canvas');
    const gl = c.getContext('webgl') || c.getContext('experimental-webgl');
    if (!gl) return 'no WebGL support';
    const dbg = gl.getExtension('WEBGL_debug_renderer_info');
    const vendor = gl.getParameter(dbg?.UNMASKED_VENDOR_WEBGL) || 'unknown';
    const renderer = gl.getParameter(dbg?.UNMASKED_RENDERER_WEBGL) || 'unknown';
    return `${vendor} / ${renderer}`;
  } catch (e) {
    return `error (${e.message})`;
  }
}

// ---------------------------------------------------------------
// Main collector – returns both data and a risk‑assessment object
// ---------------------------------------------------------------
async function collectInfo() {
  const now = new Date();

  // ------- raw data -------------------------------------------------
  const data = {
    // 1️⃣ Browser basics
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    language: navigator.language,
    languages: navigator.languages,
    cookieEnabled: navigator.cookieEnabled,
    doNotTrack: navigator.doNotTrack,

    // 2️⃣ Screen & display
    screenWidth: screen.width,
    screenHeight: screen.height,
    colorDepth: screen.colorDepth,
    pixelDepth: screen.pixelDepth,
    devicePixelRatio: window.devicePixelRatio,

    // 3️⃣ Hardware hints
    hardwareConcurrency: navigator.hardwareConcurrency, // CPU cores
    deviceMemoryGB: navigator.deviceMemory,             // RAM (GB) – may be undefined

    // 4️⃣ Timezone / locale
    timezoneOffsetMinutes: now.getTimezoneOffset(),
    localeString: now.toLocaleString(),

    // 5️⃣ Battery (only over HTTPS)
    battery: null,

    // 6️⃣ WebGL fingerprint
    webgl: getWebGLFingerprint(),

    // 7️⃣ Public IP (via external service)
    publicIP: await getPublicIP(),

    // 8️⃣ Touch & pointer
    maxTouchPoints: navigator.maxTouchPoints || 0,

    // 9️⃣ Media devices (labels hidden until permission)
    mediaDevices: null
  };

  // ----- Battery API (optional) -----
  if (navigator.getBattery) {
    try {
      const bat = await navigator.getBattery();
      data.battery = {
        charging: bat.charging,
        level: bat.level,
        chargingTime: bat.chargingTime,
        dischargingTime: bat.dischargingTime
      };
    } catch (_) {
      data.battery = 'unavailable';
    }
  }

  // ----- Media devices (optional) -----
  if (navigator.mediaDevices?.enumerateDevices) {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      data.mediaDevices = devices.map(d => ({
        kind: d.kind,
        label: d.label,   // often empty until the user grants permission
        deviceId: d.deviceId
      }));
    } catch (_) {
      data.mediaDevices = 'unavailable';
    }
  }

  // ---------------------------------------------------------------
  // Risk / mitigation mapping – one entry per field (or group)
  // ---------------------------------------------------------------
  const risk = {
    userAgent: {
      description: `Identifies browser name, version, engine and OS. Used for fingerprinting and can expose known vulnerabilities in old browsers.`,
      mitigation: `Keep your browser up‑to‑date. Use privacy‑focused browsers that can “spoof” or truncate the UA string (e.g., Firefox with “privacy.resistFingerprinting”, Brave).`
    },
    platform: {
      description: `Provides the underlying OS platform (e.g., Win32, MacIntel). Adds another fingerprinting dimension.`,
      mitigation: `Same as above – keep OS patched, and consider using extensions that block the “platform” header or use a hardened user‑agent.`
    },
    language / languages: {
      description: `Shows the preferred language(s). Can be combined with IP to infer location or ethnicity.`,
      mitigation: `Set a generic language (e.g., “en‑US”) if you don’t need a specific locale, or use a browser extension that randomizes it.`
    },
    cookieEnabled: {
      description: `Indicates whether third‑party cookies are allowed – useful for trackers to decide if they can set persistent IDs.`,
      mitigation: `Block third‑party cookies (most browsers have a setting). Use “strict” cookie policies or privacy‑enhancing extensions.`
    },
    doNotTrack: {
      description: `If set to “1”, signals that you prefer not to be tracked, but many sites simply ignore it.`,
      mitigation: `Enable Do‑Not‑Track in the browser; additionally use a tracker‑blocking extension that actively blocks known tracking domains.`
    },
    screenWidth / screenHeight / colorDepth / devicePixelRatio: {
      description: `Screen resolution and pixel density are the classic “screen size” fingerprint. Combined with other signals they can uniquely identify a device.`,
      mitigation: `Use a privacy‑focused browser that reports a generic resolution (e.g., 1024×768) or enable “canvas fingerprint protection”. Some extensions (CanvasBlocker, Trace) also randomize these values.`
    },
    hardwareConcurrency: {
      description: `Number of logical CPU cores. Helps narrow down device class (e.g., laptop vs. high‑end desktop).`,
      mitigation: `Most browsers expose the real number; some privacy extensions let you spoof a lower value (e.g., 2 cores).`
    },
    deviceMemoryGB: {
      description: `Amount of RAM (in GB). Adds another hardware fingerprint.`,
      mitigation: `If your browser supports it, you can set `navigator.deviceMemory` to a falsy value via extensions, or use a browser that simply omits it.`
    },
    timezoneOffsetMinutes: {
      description: `Local time‑zone offset – often used to infer rough geographic location.`,
      mitigation: `You can force the browser to report UTC (offset = 0) with extensions like “Temporal Privacy” or by using a VPN that also changes your system time zone.`
    },
    localeString: {
      description: `A formatted date/time string that reveals locale‑specific patterns, strengthening fingerprinting.`,
      mitigation: `Same as language settings – keep the locale generic or use extensions that rewrite `Intl` objects.`
    },
    publicIP: {
      description: `Your **public** IP address is the single strongest identifier – it can be linked to an ISP account, location, and even a household.`,
      mitigation: `Use a reputable VPN, Tor, or a proxy that masks your real IP. For added privacy, enable “IPv6 privacy extensions” on your OS.`
    },
    webgl: {
      description: `Vendor / renderer strings expose the graphics driver and GPU model. Often unique per device.`,
      mitigation: `Use a WebGL‑blocking or spoofing extension (e.g., “CanvasBlocker”) or disable WebGL entirely if you don’t need it (browser flag).`
    },
    battery: {
      description: `Battery level & charging state can give a rough estimate of device usage patterns and combine with other data to single out a device.`,
      mitigation: `Most browsers already hide battery info on insecure origins. If you want to be extra‑careful, disable the Battery API via `about:config` (Firefox) or use a privacy extension.`
    },
    maxTouchPoints: {
      description: `Indicates if the device has a touchscreen; helps differentiate mobile vs. desktop.`,
      mitigation: `Usually not a high‑risk field, but you can spoof it (e.g., set to 0) with privacy extensions.`
    },
    mediaDevices: {
      description: `Lists cameras, microphones, and speakers. Labels are empty until permission is granted, but the mere presence of devices leaks hardware capability.`,
      mitigation: `Block the `navigator.mediaDevices.enumerateDevices` call with an extension, or deny permission prompts.`
    }
  };

  return {data, risk};
}

// ---------------------------------------------------------------
// UI handling – prints JSON + risk explanations
// ---------------------------------------------------------------
document.getElementById('revealBtn').addEventListener('click', async () => {
  const out = document.getElementById('output');
  const riskDiv = document.getElementById('riskContainer');

  out.textContent = 'Collecting… please wait…';
  riskDiv.innerHTML = '';

  const {data, risk} = await collectInfo();

  // pretty‑print raw JSON
  out.textContent = JSON.stringify(data, null, 2);

  // Build a human‑readable risk list
  const sections = Object.entries(risk).map(([field, {description, mitigation}]) => {
    // For grouped fields (e.g., screenWidth/screenHeight) we show the same description
    // – the key may contain a slash, so we just display it as‑is.
    return `
      <h3>${field}</h3>
      <ul>
        <li><strong>What it reveals:</strong> ${description}</li>
        <li><strong>How to mitigate:</strong> ${mitigation}</li>
      </ul>
    `;
  }).join('');

  riskDiv.innerHTML = `
    <div class="risk">
      <h2>⚠️ What these data points can be used for & how to protect yourself</h2>
      ${sections}
    </div>
  `;
});
</script>

</body>
</html>
